From 726c79e9f2b3aba7c0800a7951047a2307d4a245 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Mon, 7 Nov 2022 14:30:42 -0500
Subject: [PATCH 3/4] Revert "netlink: split up copies in the ack construction"

This reverts commit 738136a0e3757a8534df3ad97d6ff6d7f429f6c1.
---
 include/net/netlink.h    | 21 ---------------------
 net/netlink/af_netlink.c | 31 +++++++++----------------------
 2 files changed, 9 insertions(+), 43 deletions(-)

diff --git a/include/net/netlink.h b/include/net/netlink.h
index b12cd957abb4..9a4fdfd3e54c 100644
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@ -949,27 +949,6 @@ static inline struct nlmsghdr *nlmsg_put(struct sk_buff *skb, u32 portid, u32 se
 	return __nlmsg_put(skb, portid, seq, type, payload, flags);
 }
 
-/**
- * nlmsg_append - Add more data to a nlmsg in a skb
- * @skb: socket buffer to store message in
- * @size: length of message payload
- *
- * Append data to an existing nlmsg, used when constructing a message
- * with multiple fixed-format headers (which is rare).
- * Returns NULL if the tailroom of the skb is insufficient to store
- * the extra payload.
- */
-static inline void *nlmsg_append(struct sk_buff *skb, u32 size)
-{
-	if (unlikely(skb_tailroom(skb) < NLMSG_ALIGN(size)))
-		return NULL;
-
-	if (NLMSG_ALIGN(size) - size)
-		memset(skb_tail_pointer(skb) + size, 0,
-		       NLMSG_ALIGN(size) - size);
-	return __skb_put(skb, NLMSG_ALIGN(size));
-}
-
 /**
  * nlmsg_put_answer - Add a new callback based netlink message to an skb
  * @skb: socket buffer to store message in
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 5968b6450d82..32717fb94984 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -2482,24 +2482,19 @@ void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
 		flags |= NLM_F_ACK_TLVS;
 
 	skb = nlmsg_new(payload + tlvlen, GFP_KERNEL);
-	if (!skb)
-		goto err_skb;
+	if (!skb) {
+		NETLINK_CB(in_skb).sk->sk_err = ENOBUFS;
+		sk_error_report(NETLINK_CB(in_skb).sk);
+		return;
+	}
 
 	rep = nlmsg_put(skb, NETLINK_CB(in_skb).portid, nlh->nlmsg_seq,
-			NLMSG_ERROR, sizeof(*errmsg), flags);
-	if (!rep)
-		goto err_bad_put;
+			NLMSG_ERROR, payload, flags);
 	errmsg = nlmsg_data(rep);
 	errmsg->error = err;
-	errmsg->msg = *nlh;
-
-	if (!(flags & NLM_F_CAPPED)) {
-		if (!nlmsg_append(skb, nlmsg_len(nlh)))
-			goto err_bad_put;
-
-		memcpy(nlmsg_data(&errmsg->msg), nlmsg_data(nlh),
-		       nlmsg_len(nlh));
-	}
+	unsafe_memcpy(&errmsg->msg, nlh, payload > sizeof(*errmsg)
+					 ? nlh->nlmsg_len : sizeof(*nlh),
+		      /* Bounds checked by the skb layer. */);
 
 	if (tlvlen)
 		netlink_ack_tlv_fill(in_skb, skb, nlh, err, extack);
@@ -2507,14 +2502,6 @@ void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
 	nlmsg_end(skb, rep);
 
 	nlmsg_unicast(in_skb->sk, skb, NETLINK_CB(in_skb).portid);
-
-	return;
-
-err_bad_put:
-	nlmsg_free(skb);
-err_skb:
-	NETLINK_CB(in_skb).sk->sk_err = ENOBUFS;
-	sk_error_report(NETLINK_CB(in_skb).sk);
 }
 EXPORT_SYMBOL(netlink_ack);
 
-- 
2.39.2

